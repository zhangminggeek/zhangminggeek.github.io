---
layout: post/webpack
title: webpack学习笔记（二）
tags:
  - webpack
  - 前端
categories: webpack
date: 2018-11-09 14:49:45
---


# 入口起点(Entry Points)
## 单个入口（简写）语法
用法：`entey: string|Array<string>`
**webpack.config.js**
```javascript
const config = {
  entry: './path/to/my/entry/file.js'
};

module.exports = config;
```

entry 属性的单个入口语法，是下面的简写：
```javascript
const config = {
  entry: {
    main: './path/to/my/entry/file.js'
  }
};
```

>当你向 entry 传入一个数组时会发生什么？向 entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。

## 对象语法
用法：`entry: {[entryChunkName: string]: string|Array<string>}`
**webpack.config.js**
```javascript
const config = {
  entry: {
    app: './src/app.js',
    vendors: './src/vendors.js'
  }
};
```

>“可扩展的 webpack 配置”是指，可重用并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离。然后使用专门的工具（如 webpack-merge）将它们合并。

## 常用场景
### 分离 应用程序(app) 和 第三方库(vendor) 入口
**这是什么？**从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。

**为什么？**此设置允许你使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用(vendor reference) 到 vendor bundle，并把引用 vendor 的部分替换为 __webpack_require__() 调用。如果应用程序 bundle 中没有 vendor 代码，那么你可以在 webpack 中实现被称为长效缓存的通用模式

### 多页面应用程序
**webpack.config.js**
```javascript
const config = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};
```
**这是什么？**我们告诉 webpack 需要 3 个独立分离的依赖图（如上面的示例）。

**为什么？**在多页应用中，每当页面跳转时服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：
- 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。

# 输出(Output)
## 用法
在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：
- filename 用于输出文件的文件名
- 目标输出目录 path 的绝对路径

**webpack.config.js**
```javascript
const config = {
  output: {
    filename: 'bundle.js',
    path: '/home/proj/public/assets'
  }
};

module.exports = config;
```
此配置将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中。

## 多个入口起点
如果配置创建了多个单独的 "chunk"（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。
```javascript
{
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
    filename: '[name].js',
    path: __dirname + '/dist'
  }
}

// 写入到硬盘：./dist/app.js, ./dist/search.js
```

`output.filename`：此选项决定了每个输出 bundle 的名称。

对于单个入口起点，filename 会是一个静态名称。
```javascript
filename: "bundle.js"
```

当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle，应该使用以下一种替换方式
```javascript
// 使用入口名称：
filename: "[name].bundle.js"
// 使用内部 chunk id
filename: "[id].bundle.js"
// 使用每次构建过程中，唯一的 hash 生成
filename: "[name].[hash].bundle.js"
// 使用基于每个 chunk 内容的 hash：
filename: "[chunkhash].bundle.js"
```

## 高级进阶
以下是使用 CDN 和资源 hash 的复杂示例：
```javascript
output: {
  path: "/home/proj/cdn/assets/[hash]",
  publicPath: "http://cdn.example.com/assets/[hash]/"
}
```
在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 `__webpack_public_path__`。

`output.publicPath`：此选项指定在浏览器中所引用的「此输出目录对应的公开 URL」。相对 URL(relative URL) 会被相对于 HTML 页面（或 <base> 标签）解析。相对于服务的 URL(Server-relative URL)，相对于协议的 URL(protocol-relative URL) 或绝对 URL(absolute URL) 也可是可能用到的，或者有时必须用到，例如：当将资源托管到 CDN 时。

该选项的值是以 runtime(运行时) 或 loader(载入时) 所创建的每个 URL 为前缀。因此，在多数情况下，此选项的值都会以/结束。

webpack-dev-server 也会默认从 publicPath 为基准，使用它来决定在哪个目录下启用服务，来访问 webpack 输出的文件。