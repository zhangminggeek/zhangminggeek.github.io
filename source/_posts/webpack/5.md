---
title: webpack学习笔记（五）：模块、模块解析
date: 2018-11-12 10:10:22
categories: webpack
tags: [webpack, 前端]
---

# 模块
## 什么是模块
在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。
对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：
- ES2015 import 语句
- CommonJS require() 语句
- AMD define 和 require 语句
- css/sass/less 文件中的 @import 语句。
- 样式(url(...))或 HTML 文件(`<img src=...>`)中的图片链接(image url)

## 支持的模块类型
webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) _模块_，并且在 bundle 中引入这些依赖。 webpack 社区已经为各种流行语言和语言处理器构建了 loader，包括：
- CoffeeScript
- TypeScript
- ESNext (Babel)
- Sass
- Less
- Stylus

# 模块解析
resolver 是一个库(library)，用于帮助找到模块的绝对路径。一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：
```javascript
import foo from 'path/to/module'
// 或者
require('path/to/module')
```
所依赖的模块可以是来自应用程序代码或第三方的库(library)。resolver 帮助 webpack 找到 bundle 中需要引入的模块代码，这些代码在包含在每个 require/import 语句中。 当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径

## webpack中的解析规则
使用 enhanced-resolve，webpack 能够解析三种文件路径：

### 绝对路径
```javascript
import "/home/me/file";

import "C:\\Users\\me\\file";
```

### 相对路径
```javascript
import "../src/file1";
import "./file2";
```
在这种情况下，使用 import 或 require 的资源文件(resource file)所在的目录被认为是上下文目录(context directory)。在 import/require 中给定的相对路径，会添加此上下文路径(context path)，以产生模块的绝对路径(absolute path)。

### 模块路径
```javascript
import "module";
import "module/lib/file";
```
模块将在 resolve.modules 中指定的所有目录内搜索。 你可以替换初始模块路径，此替换路径通过使用 resolve.alias 配置选项来创建一个别名。
一旦根据上述规则解析路径后，解析器(resolver)将检查路径是否指向文件或目录。如果路径指向一个文件：
- 如果路径具有文件扩展名，则被直接将文件打包。
- 否则，将使用 [resolve.extensions] 选项作为文件扩展名来解析，此选项告诉解析器在解析中能够接受哪些扩展名（例如 .js, .jsx）。

如果路径指向一个文件夹，则采取以下步骤找到具有正确扩展名的正确文件：
- 如果文件夹中包含 package.json 文件，则按照顺序查找 resolve.mainFields 配置选项中指定的字段。并且 package.json 中的第一个这样的字段确定文件路径。
- 如果 package.json 文件不存在或者 package.json 文件中的 main 字段没有返回一个有效路径，则按照顺序查找 resolve.mainFiles 配置选项中指定的文件名，看是否能在 import/require 目录下匹配到一个存在的文件名。
- 文件扩展名通过 resolve.extensions 选项采用类似的方法进行解析。

#### `resolve.aliasFields`
`string`
指定一个字段，例如 browser，根据此规范进行解析。默认：
```javascript
aliasFields: ["browser"]
```

#### `resolve.extensions`
`array`
自动解析确定的扩展。默认值为：
```javascript
extensions: [".js", ".json"]
```
能够使用户在引入模块时不带扩展：
```javascript
import File from '../path/to/file'
```
>使用此选项，会覆盖默认数组，这就意味着 webpack 将不再尝试使用默认扩展来解析模块。对于使用其扩展导入的模块，例如，import SomeFile from "./somefile.ext"，要想正确的解析，一个包含“*”的字符串必须包含在数组中

#### `resolve.mainFields`
`array`
当从 npm 包中导入模块时（例如，import * as D3 from "d3"），此选项将决定在 package.json 中使用哪个字段导入模块。根据 webpack 配置中指定的 target 不同，默认值也会有所不同。
当 target 属性设置为 webworker, web 或者没有指定，默认值为：
```javascript
mainFields: ["browser", "module", "main"]
```
对于其他任意的 target（包括 node），默认值为：
```javascript
mainFields: ["module", "main"]
```
例如，D3 的 package.json 含有这些字段：
```javascript
{
  ...
  main: 'build/d3.Node.js',
  browser: 'build/d3.js',
  module: 'index',
  ...
}
```
这意味着当我们 import * as D3 from "d3"，实际从 browser 属性解析文件。在这里 browser 属性是最优先选择的，因为它是 mainFields 的第一项。同时，由 webpack 打包的 Node.js 应用程序默认会从 module 字段中解析文件。

#### `resolve.mainFiles`
`array`
解析目录时要使用的文件名。默认
```javascript
mainFiles: ["index"]
```

## 解析loader
Loader 解析遵循与文件解析器指定的规则相同的规则。但是 resolveLoader 配置选项可以用来为 Loader 提供独立的解析规则。

### resolveLoader
#### `resolveLoader`
`object`
这组选项与上面的 resolve 对象的属性集合相同，但仅用于解析 webpack 的 loader 包。默认：
```javascript
{
  modules: [ 'node_modules' ],
  extensions: [ '.js', '.json' ],
  mainFields: [ 'loader', 'main' ]
}
```
>注意，这里你可以使用别名，并且其他特性类似于 resolve 对象。例如，{ txt: 'raw-loader' } 会使用 raw-loader 去 shim(填充) txt!templates/demo.txt。

#### `resolveLoader.moduleExtensions`
`array`
解析 loader 时，用到扩展名(extensions)/后缀(suffixes)。从 webpack 2 开始，我们强烈建议使用全名，例如 example-loader，以尽可能清晰。然而，如果你确实想省略 -loader，也就是说只使用 example，则可以使用此选项来实现：
```javascript
moduleExtensions: [ '-loader' ]
```


## 缓存
每个文件系统访问都被缓存，以便更快触发对同一文件的多个并行或串行请求。在观察模式下，只有修改过的文件会从缓存中摘出。如果关闭观察模式，在每次编译前清理缓存。

### watch 和 watchOptions
#### `watch`
`boolean`
启用 Watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。Watch 模式默认关闭。
```javascript
watch: false
```
>webpack-dev-server 和 webpack-dev-middleware 里 Watch 模式默认开启。

#### `watchOptions`
`object`
一组用来定制 Watch 模式的选项：
```javascript
watchOptions: {
  aggregateTimeout: 300,
  poll: 1000
}
```

#### `watchOptions.aggregateTimeout`
`number`
当第一个文件更改，会在重新构建前增加延迟。这个选项允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里。以毫秒为单位：
```javascript
aggregateTimeout: 300 // 默认值
```

#### `watchOptions.ignored`
对于某些系统，监听大量文件系统会导致大量的 CPU 或内存占用。这个选项可以排除一些巨大的文件夹，例如 node_modules：
```javascript
ignored: /node_modules/
```
也可以使用 anymatch 模式：
```javascript
ignored: "files/**/*.js"
```

#### `watchOptions.poll`
`boolean``number`
通过传递 true 开启 polling，或者指定毫秒为单位进行轮询。
```javascript
poll: 1000 // 每秒检查一次变动
```

#### `info-verbosity`
`string`: `none``info``verbose`
控制生命周期消息的详细程度，例如 Started watching files(开始监听文件)... 日志。将 info-verbosity 设置为 verbose，还会额外在增量构建的开始和结束时，向控制台发送消息。info-verbosity 默认设置为 info。
```javascript
webpack --watch --info-verbosity verbose
```